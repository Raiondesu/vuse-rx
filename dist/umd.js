(function(c,s){typeof exports=="object"&&typeof module<"u"?s(exports,require("rxjs"),require("vue"),require("rxjs/operators")):typeof define=="function"&&define.amd?define(["exports","rxjs","vue","rxjs/operators"],s):(c=typeof globalThis<"u"?globalThis:c||self,s(c.vuseRx={},c.rxjs,c.Vue,c.rxjs.operators))})(this,function(c,s,r,u){"use strict";const $=e=>new s.Observable(n=>{r.getCurrentInstance()&&e(()=>n.next())}),j=e=>u.takeUntil($(e)),p=j(r.onUnmounted),k=(e,n,t)=>n!=null&&typeof n[t]=="object"&&typeof e[t]=="object",O=e=>n=>{for(const t in n){const o=n[t];e[t]=!Array.isArray(o)&&k(e,n,t)?O(e[t])(o):o}return e},U={mutationStrategy:O};function q(e,n){const{mutationStrategy:t}={...U,...n};return function(o,i){const f=r.reactive(g(e)),d={},l={},m=[];let b=!1,R;const F={error:a=>{R=a},complete:()=>{b=!0}};for(const a in o){const y=new s.Subject;d[a]=(...S)=>y.next(o[a].apply(o,S)),m.push(l[`${a}$`]=u.mergeScan((S,h)=>(h=g(h,S,F),(s.isObservable(h)?h:s.of(h)).pipe(u.map(t(S,t)),u.tap({next:()=>R?R=y.error(R):b&&y.complete()}))),f)(y))}const M=s.merge(...m);return x({actions:d,state:r.readonly(f),state$:p(i?i(M,o,f,l,F).pipe(u.scan((a,y)=>t(a,t)(y),f)):M),actions$:l})}}const x=e=>({...e,subscribe:(...n)=>({...e,subscription:e.state$.subscribe(...n)})}),g=(e,...n)=>typeof e=="function"?e(...n):e,A=e=>n=>{for(const t in n)e[t]=k(e,n,t)?A(e[t])(n[t]):n[t];return e},E=e=>n=>{for(const t in n)e[t]=n[t];return e},P=e=>u.catchError((n,t)=>{throw e(n,t)}),T=e=>u.tap({next:n=>e.value=n});function v(e,n){return p(new s.Observable(t=>r.watch(e,o=>t.next(o),n)))}function H(e,n){if(typeof e=="object"&&!r.isProxy(e))try{const t=r.ref(n);return p(s.from(e)).subscribe({next:o=>t.value=o}),t}catch{}return r.isProxy(e)?r.toRef(e,n):r.ref(e)}function C(e,n={}){const t=r.ref(n.next),o=r.ref(n.error),i=p(s.from(e));return{next:t,error:o,value$:i,subscription:i.subscribe({next:f=>t.value=f,error:f=>o.value=f})}}function w(e,n,t){const o=r.ref(t??(n.to?n.to(e.value):e.value));for(const i in n)(o[i]=I(e,o,n,i,this)).bind();return o}w.with=(...e)=>{const n=Object.assign({},...e),t=w.bind(n);return t.with=w.with.bind(n),t};const I=(e,n,t,o,i)=>({bind:f=>{const{ref:d,map:l,watch:m}={ref:e,map:t[o],watch:i,...f};n[o].stop(),n[o].stop=o==="to"?r.watch(d,b=>n.value=l(b),Object.assign({},i,m)):r.watch(n,b=>d.value=l(b),Object.assign({},i,m))},stop:()=>{}}),K=e=>r.onUnmounted(()=>e.unsubscribe());c.deep=A,c.deepReplaceArray=O,c.defaultOptions=U,c.fromHook=$,c.fromRef=v,c.mapError=P,c.pipeUntil=j,c.refFrom=H,c.refsFrom=C,c.setRef=T,c.shallow=E,c.syncRef=w,c.untilUnmounted=p,c.useRxState=q,c.useSubscription=K,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=umd.js.map
