(function(c,s){typeof exports=="object"&&typeof module<"u"?s(exports,require("rxjs"),require("vue"),require("rxjs/operators")):typeof define=="function"&&define.amd?define(["exports","rxjs","vue","rxjs/operators"],s):(c=typeof globalThis<"u"?globalThis:c||self,s(c.vuseRx={},c.rxjs,c.Vue,c.rxjs.operators))})(this,function(c,s,r,u){"use strict";const j=e=>new s.Observable(n=>{r.getCurrentInstance()&&e(()=>n.next())}),S=e=>u.takeUntil(j(e)),p=S(r.onUnmounted),k=(e,n,t)=>n!=null&&typeof n[t]=="object"&&typeof e[t]=="object",$=e=>n=>{for(const t in n){const o=n[t];e[t]=!Array.isArray(o)&&k(e,n,t)?$(e[t])(o):o}return e},U={mutationStrategy:$};function M(e,n){const{mutationStrategy:t}={...U,...n};return function(o,i){const f=r.reactive(g(e)),d={},l={},m=[];let b=!1,R;const A={error:a=>{R=a},complete:()=>{b=!0}};for(const a in o){const y=new s.Subject;d[a]=(...O)=>y.next(o[a].apply(o,O)),m.push(l[`${a}$`]=u.mergeScan((O,h)=>(h=g(h,O,A),(s.isObservable(h)?h:s.of(h)).pipe(u.map(t(O,t)),u.tap({next:()=>R?R=y.error(R):b&&y.complete()}))),f)(y))}const F=s.merge(...m);return q({actions:d,state:r.readonly(f),state$:p(i?i(F,o,f,l,A).pipe(u.scan((a,y)=>t(a,t)(y),f)):F),actions$:l})}}const q=e=>({...e,subscribe:(...n)=>({...e,subscription:e.state$.subscribe(...n)})}),g=(e,...n)=>typeof e=="function"?e(...n):e,v=e=>n=>{for(const t in n)e[t]=k(e,n,t)?v(e[t])(n[t]):n[t];return e},x=e=>n=>{for(const t in n)e[t]=n[t];return e},E=e=>u.catchError((n,t)=>{throw e(n,t)}),T=e=>u.tap({next:n=>e.value=n});function H(e,n){return p(new s.Observable(t=>r.watch(e,o=>t.next(o),n)))}function P(e,n){if(typeof e=="object")try{const t=r.ref(n);return p(s.from(e)).subscribe({next:o=>t.value=o}),t}catch{}return r.isProxy(e)?r.toRef(e,n):r.ref(e)}function C(e,n={}){const t=r.ref(n.next),o=r.ref(n.error),i=p(s.from(e));return{next:t,error:o,value$:i,subscription:i.subscribe({next:f=>t.value=f,error:f=>o.value=f})}}function w(e,n,t){const o=r.ref(t??(n.to?n.to(e.value):e.value));for(const i in n)(o[i]=I(e,o,n,i,this)).bind();return o}w.with=(...e)=>{const n=Object.assign({},...e),t=w.bind(n);return t.with=w.with.bind(n),t};const I=(e,n,t,o,i)=>({bind:f=>{const{ref:d,map:l,watch:m}={ref:e,map:t[o],watch:i,...f};n[o].stop(),n[o].stop=o==="to"?r.watch(d,b=>n.value=l(b),Object.assign({},i,m)):r.watch(n,b=>d.value=l(b),Object.assign({},i,m))},stop:()=>{}});c.deep=v,c.deepReplaceArray=$,c.defaultOptions=U,c.fromHook=j,c.fromRef=H,c.mapError=E,c.pipeUntil=S,c.refFrom=P,c.refsFrom=C,c.setRef=T,c.shallow=x,c.syncRef=w,c.untilUnmounted=p,c.useRxState=M,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=umd.js.map
