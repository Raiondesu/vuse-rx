(function(c,s){typeof exports=="object"&&typeof module<"u"?s(exports,require("rxjs"),require("vue"),require("rxjs/operators")):typeof define=="function"&&define.amd?define(["exports","rxjs","vue","rxjs/operators"],s):(c=typeof globalThis<"u"?globalThis:c||self,s(c.vuseRx={},c.rxjs,c.Vue,c.rxjs.operators))})(this,function(c,s,r,u){"use strict";const O=e=>new s.Observable(n=>{r.getCurrentInstance()&&e(()=>n.next())}),S=e=>u.takeUntil(O(e)),p=S(r.onUnmounted),k=(e,n,t)=>n!=null&&typeof n[t]=="object"&&typeof e[t]=="object",j=e=>n=>{for(const t in n){const o=n[t];e[t]=!Array.isArray(o)&&k(e,n,t)?j(e[t])(o):o}return e},A={mutationStrategy:j};function F(e,n){const{mutationStrategy:t}={...A,...n};return function(o,i){const f=r.reactive(U(e)),m={},l={},d=[];let b=!1,R;const v={error:a=>{R=a},complete:()=>{b=!0}};for(const a in o){const y=new s.Subject;m[a]=(...$)=>y.next(o[a].apply(o,$)),d.push(l[`${a}$`]=u.mergeScan(($,h)=>(h=U(h,$,v),(s.isObservable(h)?h:s.of(h)).pipe(u.map(t($,t)),u.tap({next:()=>R?R=y.error(R):b&&y.complete()}))),f)(y))}const x=s.merge(...d);return M({actions:m,state:r.readonly(f),state$:p(i?i(x,o,f,l,v).pipe(u.scan((a,y)=>t(a,t)(y),f)):x),actions$:l})}}const M=e=>({...e,subscribe:(...n)=>({...e,subscription:e.state$.subscribe(...n)})}),U=(e,...n)=>typeof e=="function"?e(...n):e,g=e=>n=>{for(const t in n)e[t]=k(e,n,t)?g(e[t])(n[t]):n[t];return e},q=e=>n=>{for(const t in n)e[t]=n[t];return e},E=e=>u.catchError((n,t)=>{throw e(n,t)}),T=e=>u.tap({next:n=>e.value=n});function H(e,n){return p(new s.Observable(t=>r.watch(e,o=>t.next(o),n)))}function P(e,n){if(typeof e=="object")try{const t=r.ref(n);return p(s.from(e)).subscribe({next:o=>t.value=o}),t}catch{}return r.isProxy(e)?r.toRef(e,n):r.ref(e)}function C(e,n={}){const t=r.ref(n.next),o=r.ref(n.error),i=p(s.from(e));return{next:t,error:o,value$:i,subscription:i.subscribe({next:f=>t.value=f,error:f=>o.value=f})}}function w(e,n,t){const o=r.ref(t??(n.to?n.to(e.value):e.value));for(const i in n)(o[i]=I(e,o,n,i,this)).bind();return o}w.with=(...e)=>{const n=Object.assign({},...e),t=w.bind(n);return t.with=w.with.bind(n),t};const I=(e,n,t,o,i)=>({bind:f=>{const{ref:m,map:l,watch:d}={ref:e,map:t[o],watch:i,...f};n[o].stop(),n[o].stop=o==="to"?r.watch(m,b=>n.value=l(b),Object.assign({},i,d)):r.watch(n,b=>m.value=l(b),Object.assign({},i,d))},stop:()=>{}});c.deep=g,c.deepReplaceArray=j,c.fromHook=O,c.fromRef=H,c.mapError=E,c.pipeUntil=S,c.refFrom=P,c.refsFrom=C,c.setRef=T,c.shallow=q,c.syncRef=w,c.untilUnmounted=p,c.useRxState=F,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=umd.js.map
