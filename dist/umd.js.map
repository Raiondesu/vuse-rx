{"version":3,"file":"umd.js","sources":["../src/hooks/from.ts","../src/operators/until.ts","../src/use-rx/common.ts","../src/use-rx/strategies/deepReplaceArray.ts","../src/use-rx/use-rx-state.ts","../src/use-rx/strategies/deep.ts","../src/use-rx/strategies/shallow.ts","../src/operators/map-error.ts","../src/operators/set-ref.ts","../src/rx-refs/from-ref.ts","../src/rx-refs/ref-from.ts","../src/rx-refs/refs-from.ts","../src/rx-refs/sync-ref.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport { getCurrentInstance } from 'vue';\n\nexport type VueHook = (hook: () => any, ...args: any[]) => any;\n\n/**\n * Creates an observable that emits when a vue hook is executed\n *\n * If subscribed to outside the component scope - equivalent to a NEVER observable\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const fromHook = (hook: VueHook) => new Observable<void>(\n  ctx => { getCurrentInstance() && hook(() => ctx.next()) }\n);\n","import type { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { onUnmounted } from 'vue';\nimport { VueHook, fromHook } from '../hooks/from';\n\n/**\n * Creates an takeUntil that emits when a vue hook is executed\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const pipeUntil = <T>(hook: VueHook) => takeUntil<T>(fromHook(hook));\n\n/**\n * Stops an observable when a vue component is unmounted\n *\n * @param $ - obserable to stop on unmounted\n *\n * ---\n */\nexport const untilUnmounted: <T>($: Observable<T>) => Observable<T> = pipeUntil(onUnmounted);\n","export type Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type MutationStrategy<S extends Record<PropertyKey, any>, M> = {\n  /**\n   * Creates a mutation applier\n   *\n   * @param state - a base state to mutate\n   * @param strategy - current mutation strategy\n   */\n  (state: S, strategy: MutationStrategy<S, M>): (mutation: M) => S;\n};\n\n/**\n * Checks if it's possible to advance deeper\n * into the sibling object structures,\n * with one being partial\n *\n * @param state - the object source\n * @param mutation - the main checking reference\n * @param key - a key into which to advance\n */\nexport const canMergeDeep = <S extends Record<PropertyKey, any>, Mutation extends Record<keyof S, any>>(\n  state: S,\n  mutation: Mutation | null | undefined,\n  key: keyof S,\n) => (\n  mutation != null\n  && typeof mutation[key] === 'object'\n  && typeof state[key] === 'object'\n);\n","import { Builtin, canMergeDeep } from '../common';\n\nexport type DeepReplaceArrayMutation<T> = T extends Builtin | Array<any> | ReadonlyArray<any>\n  ? T\n  : T extends Record<any, any>\n  ? { [K in keyof Partial<T>]: DeepReplaceArrayMutation<T[K]> }\n  : Partial<T>;\n\n/**\n * Default merge strategy for mutations\n *\n * Deep-merges state and mutation objects recursively,\n * by enumerable keys (`for..in`),\n * but replaces arrays and primitives\n */\nexport const deepReplaceArray = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepReplaceArrayMutation<S>\n) => {\n  for (const key in mutation) {\n    const submutation = mutation[key];\n\n    state[key as keyof S] = !Array.isArray(submutation) && canMergeDeep(state, mutation, key)\n      ? deepReplaceArray(state[key])(submutation)\n      : submutation as S[keyof S];\n  }\n\n  return state;\n};\n","import type { Observable, PartialObserver, Subscription } from 'rxjs';\nimport type { DeepReadonly, UnwrapNestedRefs } from 'vue';\n\nimport { isObservable, merge, of, Subject } from 'rxjs';\nimport { map, mergeScan, scan, tap } from 'rxjs/operators';\nimport { reactive, readonly } from 'vue';\nimport { untilUnmounted } from '../operators/until';\nimport { MutationStrategy } from './common';\nimport { deepReplaceArray, DeepReplaceArrayMutation } from './strategies/deepReplaceArray';\n\n\nexport interface RxStateOptions<S extends Record<PropertyKey, any>, Mutaiton> {\n  mutationStrategy: MutationStrategy<S, Mutaiton>;\n}\n\nexport const defaultOptions = {\n  mutationStrategy: deepReplaceArray,\n};\n\n/**\n * Allows to bind reducers to a state and an observable.\n *\n * First accepts state's default value and a state merge strategy,\n * then accepts a map of state reducers.\n *\n * @param initialState - a factory or initial value for the reactive state\n * @param options - options to customize the behavior, for example - to apply a custom strategy of merging a mutation with an old state\n */\nexport function useRxState<T extends Record<PropertyKey, any>, Mutation = DeepReplaceArrayMutation<UnwrapNestedRefs<T>>>(\n  initialState: T | (() => T),\n  options?: Partial<RxStateOptions<UnwrapNestedRefs<T>, Mutation>>\n): CreateRxState<UnwrapNestedRefs<T>, Mutation> {\n  const { mutationStrategy: mergeKeys } = {\n    ...defaultOptions as RxStateOptions<UnwrapNestedRefs<T>, Mutation>,\n    ...options\n  };\n\n  return function (reducers, map$?) {\n    type S = UnwrapNestedRefs<T>;\n    type ReducerResult = ReturnType<StateReducer<S, Mutation>>;\n    type Actions = ReducerActions<typeof reducers>;\n\n    const state = reactive(callMeMaybe(initialState));\n\n    const actions = <Actions> {};\n    const actions$ = <ReducerObservables<Actions, S>> {};\n    const actions$Arr = <Observable<S>[]> [];\n\n    let complete = false;\n    let error: any = undefined;\n\n    const context: MutationContext = {\n      error: e => { error = e; },\n      complete: () => { complete = true; }\n    };\n\n    for (const key in reducers) {\n      const mutations$ = new Subject<ReducerResult>();\n\n      actions[key] = <ReducerAction<typeof reducers[typeof key]>>(\n        (...args: any[]) => mutations$.next(\n          reducers[key].apply(reducers, args)\n        )\n      );\n\n      actions$Arr.push(\n        actions$[`${key}$` as const] = (\n          mergeScan((prev: S, curr: ReducerResult) => {\n            curr = callMeMaybe(curr, prev, context);\n\n            return (\n              isObservable(curr)\n                ? curr\n                : of(curr)\n            ).pipe(\n              map(mergeKeys(prev, mergeKeys)),\n              tap({\n                next: () => error\n                  ? error = mutations$.error(error)\n                  : complete && mutations$.complete()\n              })\n            )\n          }, state)(mutations$)\n        )\n      );\n    }\n\n    const merged$ = merge(...actions$Arr);\n\n    return createRxResult({\n      actions,\n      state: readonly(state as T),\n      state$: untilUnmounted(\n        map$ ? map$(\n          merged$,\n          reducers,\n          state,\n          actions$,\n          context,\n        ).pipe(\n          scan((prev, curr) => mergeKeys(prev, mergeKeys)(curr), state)\n        ) : merged$\n      ),\n      actions$: actions$ as ReducerObservables<Actions, DeepReadonly<S>>,\n    });\n  };\n}\n\ntype CreateRxState<S, Mutation> = {\n  /**\n   * Allows to bind reducers to a state and an observable.\n   *\n   * Accepts a map of state reducers.\n   *\n   * Each reducer can either return:\n   * * an updated part of the state:\n   *   ```\n   *   (v) => ({ value: v })\n   *   ```\n   * * an observable that emits an updated part of the state:\n   *   ```\n   *   (v) => new BehaviorSubject({ value: v })\n   *   ```\n   * * a function that accepts the old state and returns either of the previous types:\n   *   ```\n   *   (v) => (oldState) => ({\n   *       value: oldState.value > v ? oldState.value : v\n   *   })\n   *   ```\n   *\n   * @param reducers a map of reducers to mutate the state\n   * @param map$ a function to modify the resulting observable\n   */\n  <R extends StateReducers<S, Mutation>>(\n    reducers: R,\n    map$?: (\n      state$: Observable<S>,\n      reducers: R,\n      state: S,\n      actions$: Record<Action$<Extract<keyof R, string>>, Observable<S>>,\n      context: MutationContext\n    ) => Observable<Mutation>\n  ): SubscribableRxResult<ReducerActions<R>, S>;\n};\n\nconst createRxResult = <S, Actions>(result: {\n  actions: Actions,\n  state: DeepReadonly<S>,\n  state$: Observable<S>,\n  actions$: ReducerObservables<Actions, DeepReadonly<S>>\n}): SubscribableRxResult<Actions, S> => ({\n  ...result,\n  subscribe: (...args: any[]) => ({\n    ...result,\n    subscription: result.state$.subscribe(...args),\n  }),\n})\n\nconst callMeMaybe = <T, A extends any[]>(\n  fn: T | ((...args: A) => T),\n  ...args: A\n) => (\n  typeof fn === 'function'\n    ? (fn as (...args: A) => T)(...args)\n    : fn\n);\n\nexport interface MutationContext {\n  error(error: any): void;\n  complete(): void;\n}\n\nexport type StatefulMutation<S, Mutation> = (state: S, mutation?: MutationContext) => Mutation | Observable<Mutation>;\n\n/**\n * A reducer for the observable state\n */\nexport type StateReducer<S, Mutation, Args extends any[] = any[]> = (\n  (...args: Args) =>\n    | Mutation\n    | Observable<Mutation>\n    | StatefulMutation<S, Mutation>\n);\n\n/**\n * A named collection of state reducers\n */\nexport type StateReducers<S, Mutation> = Record<string, StateReducer<S, Mutation>>;\n\n/**\n * A method action generated from a StateReducer\n */\nexport type ResAction<A extends any[] = []> = (...args: A) => void;\n\ntype Action$<Name extends string> = `${Name}$`;\n\ntype ReducerObservables<H, R> = {\n  [key in Action$<Extract<keyof H, string>>]: Observable<R>;\n};\n\n/**\n * Resulting RX bindings:\n *\n * * actions - a named collection of ResAction-s\n * * state - a reactive vue state\n * * state$ - an rxjs observable\n */\nexport interface RxResult<Actions, State> {\n  readonly actions: Actions;\n  readonly state: DeepReadonly<State>;\n  readonly state$: Observable<State>;\n  readonly actions$: ReducerObservables<Actions, DeepReadonly<State>>;\n};\n\nexport interface SubscribableRxResult<Actions, State> extends RxResult<Actions, State> {\n  readonly subscribe: {\n    (observer?: PartialObserver<State>): SubscriptionRxResult<Actions, State>;\n    (...args: Parameters<Observable<State>['subscribe']>): SubscriptionRxResult<Actions, State>;\n  };\n};\n\nexport interface SubscriptionRxResult<Actions, State> extends RxResult<Actions, State> {\n  readonly subscription: Subscription;\n}\n\ntype ReducerAction<R> = R extends StateReducer<any, any, infer Args>\n  ? ResAction<Args>\n  : never;\n\ntype ReducerActions<R> = { [key in keyof R]: ReducerAction<R[key]> };\n","import { canMergeDeep } from '../common';\n\nexport type Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type DeepMutation<T> = T extends Builtin\n  ? T\n  : T extends Array<infer U>\n  ? Array<DeepMutation<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepMutation<U>>\n  : T extends Record<any, any>\n  ? { [K in keyof Partial<T>]: DeepMutation<T[K]> }\n  : Partial<T>;\n\n/**\n * A deep-merge strategy for mutations\n *\n * Deep-merges state and mutation recursively,\n * by enumerable keys (`for..in`),\n * so avoid recursive object links\n */\nexport const deep = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepMutation<S>\n) => {\n  for (const key in mutation) {\n    state[key as keyof S] = canMergeDeep(state, mutation, key)\n      ? deep(state[key])(mutation[key])\n      : mutation[key] as S[keyof S];\n  }\n\n  return state;\n};\n","export type ShallowMutation<S> = {\n  // Hack to avoid double `undefined` in `[key]?: value | undefined`\n  [K in keyof Partial<S>]: S[K];\n};\n\n/**\n * A merge strategy for mutations\n *\n * Shallow-merges state and mutation recursively,\n * by enumerable keys (`for..in`)\n */\nexport const shallow = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: ShallowMutation<S>\n) => {\n  for (const key in mutation) {\n    state[key] = mutation[key];\n  }\n\n  return state;\n};\n","import { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport const mapError = <T, O, R>(cb: (e: T, $: Observable<O>) => R) => (\n  catchError<O, Observable<O>>((e, $) => { throw cb(e, $); })\n);\n","import { tap } from 'rxjs/operators';\nimport { Ref } from 'vue';\n\nexport const setRef = <T>(ref: Ref<T>) => tap<T>({ next: v => ref.value = v });\n","import { Observable } from 'rxjs';\nimport { watch, WatchOptions, WatchSource } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\n/**\n * Creates an observable from a vue ref.\n *\n * Each time a ref's value is changed - observable emits.\n *\n * Can also accept vue reactive objects and value factories.\n *\n * @param ref - a ref/reactive/factory to observe\n * @returns an observable that watches the ref\n */\nexport function fromRef<R>(ref: WatchSource<R>, options?: WatchOptions): Observable<R>;\n\n/**\n * Creates an observable from a vue reactive state.\n *\n * Each time a state's value is changed - observable emits.\n *\n * @param ref - a reactive state to observe\n * @returns an observable that watches the state\n */\nexport function fromRef<R extends Record<string, any>>(reactiveState: R, options?: WatchOptions): Observable<R>;\nexport function fromRef(ref: Record<string, unknown> | WatchSource<unknown>, options?: WatchOptions): Observable<unknown> {\n  return untilUnmounted(\n    new Observable(ctx => watch(ref, value => ctx.next(value), options))\n  );\n};\n","import { from, ObservableInput } from 'rxjs';\nimport { isProxy, Ref, ref, toRef, UnwrapRef } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is resolved, the ref is set to the resulting value.\n *\n * The ref will contain `undefined` until the promise is resolved.\n *\n * @param promise to set from\n */\nexport function refFrom<R>(promise: Promise<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is fulfilled, the ref is set to the resulting value.\n * Until then, the ref will contain the passed default value.\n *\n * @param promise to set from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(promise: Promise<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: R): Ref<UnwrapRef<R>>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n *\n * The ref will contain `undefined` until the observable emits.\n *\n * @param observableInput an input to create an observable form and then listen to it\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n * Until then, the ref will contain the passed default value.\n *\n * @param observableInput an input to create an observable form and then listen to it\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * Works exactly like toRef:\n * creates a ref from a reactive state.\n *\n * @param state a reactive state to bind from\n * @param key a key of the state to bind\n */\nexport function refFrom<R extends Record<any, any>, K extends keyof R>(state: R, key: K): Ref<UnwrapRef<R[K]>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R, defaultValue: R): Ref<UnwrapRef<R>>;\n\nexport function refFrom(arg: unknown, subArg?: unknown) {\n  if (typeof arg === 'object') try {\n    const ref$ = ref(subArg);\n\n    untilUnmounted(from(arg as any)).subscribe({\n      next: value => ref$.value = value\n    });\n\n    return ref$;\n  } catch (_) { /* Silence the error to try other ways */ }\n\n  return isProxy(arg)\n    ? toRef(arg as Record<any, any>, subArg)\n    : ref(arg);\n}\n","import { ObservableInput, from, Subscription, Observable } from 'rxjs';\nimport { Ref, ref } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\ntype Subscribers<R, E> = { next: R; error: E; };\n\ntype Refs<R, E> = {\n  [key in keyof Subscribers<R, E>]: Ref<Subscribers<R, E>[key]>;\n} & {\n  subscription: Subscription;\n  value$: Observable<R>;\n};\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * Until the observable emits, the refs will contain `undefined`.\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>): Refs<R | undefined, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>, defaultValues: { next: R }): Refs<R, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E>(input: ObservableInput<R>, defaultValues: Subscribers<R, E>): Refs<R, E>;\n\nexport function refsFrom(input: ObservableInput<any>, defaultValues: Partial<Subscribers<any, any>> = {}) {\n  const next = ref(defaultValues.next);\n  const error = ref(defaultValues.error);\n  const value$ = untilUnmounted(from(input));\n\n  return {\n    next,\n    error,\n    value$,\n    subscription: value$.subscribe({\n      next: v => next.value = v,\n      error: v => error.value = v,\n    })\n  };\n}\n","import { Ref, UnwrapRef, ref, watch, WatchOptions, WatchStopHandle } from 'vue';\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto the first.\n */\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to }: { to: Mapper<R1, UnwrapRef<R2>> },\n): SyncedRef<R1, 'to', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { from }: { from: Mapper<UnwrapRef<R2>, R1> },\n  defaultValue?: R2,\n): SyncedRef<R1, 'from', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: { to: Mapper<R1, UnwrapRef<R2>>, from: Mapper<UnwrapRef<R2>, R1> },\n): SyncedRef<R1, 'to' | 'from', UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto the first.\n */\nexport function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  defaultValue?: R2,\n): SyncedRef<R1, keyof M, UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The second ref serves as an origin point for the binding,\\\n * values **from** the second ref and **to** the second ref are mapped onto the first.\n */\nexport function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  ref2: Ref<R2>,\n): SyncedRef<R1, keyof M, R2>;\n\nexport function syncRef<R1, R2>(\n  this: WatchOptions,\n  ref1: Ref<R1>,\n  maps: Mappers<R1, R2>,\n  _ref2?: Ref<R2> | R2,\n): _SyncedRef<R1, keyof Mappers<R1, R2>, R2> {\n  const ref2 = ref(\n    _ref2 == null\n      ? maps.to\n        ? maps.to(ref1.value)\n        : ref1.value\n      : _ref2\n  ) as _SyncedRef<R1, keyof Mappers<R1, R2>, R2>;\n\n  for (const key in maps) (\n    ref2[key as keyof typeof maps] = bind(ref1, ref2, maps, key as any, this)\n  ).bind();\n\n  return ref2;\n}\n\nsyncRef.with = <T extends Readonly<boolean> = false>(\n  ...options: WatchOptions<T>[]\n): typeof syncRef => {\n  const opts = Object.assign({}, ...options);\n  const f = syncRef.bind(opts);\n  f.with = syncRef.with.bind(opts);\n  return f;\n}\n\nconst bind = <R1, R2>(\n  refBase: Ref<R1>,\n  refDest: _SyncedRef<R1, keyof Mappers<R1, R2>, R2>,\n  maps: Mappers<R1, R2>,\n  dir: keyof Mappers<R1, R2>,\n  options: WatchOptions,\n) => ({\n  bind: (bindOptions?: Partial<BindingOptions<R1, R2, keyof Mappers<R1, R2>>>) => {\n    const {\n      ref, map, watch: opts\n    }: BindingOptions<any, R2, any> = {\n      ref: refBase,\n      map: maps[dir]!,\n      watch: options,\n      ...bindOptions,\n    };\n\n    refDest[dir]!.stop();\n\n    refDest[dir]!.stop = dir === 'to'\n      ? watch(ref, v => refDest.value = map(v), Object.assign({}, options, opts))\n      : watch(refDest, v => ref.value = map(v), Object.assign({}, options, opts));\n  },\n  stop: () => {}\n});\n\ntype Mapper<F, T> = (value: F) => T;\n\ntype Mappers<R1, R2> = {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from?: never,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to?: never,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n};\n\ntype Binders<R1, R2, Keys extends PropertyKey> = {\n  [key in Keys]: {\n    /**\n     * Cut the binding in this direction\n     */\n    stop: WatchStopHandle;\n    bind: {\n      /**\n       * Reapply the binding in this direction\n       */\n      (): void;\n\n      /**\n       * Bind this direction to a new ref\n       */\n      (options?: BindingOptions<R1, R2, key>): void;\n\n      /**\n       * Bind this direction to a new ref with a new map\n       */\n      <T>(options: CustomBindingOptions<T, R2, key>): void;\n    };\n  };\n};\n\nexport type BindingOptions<R1, R2, Key extends PropertyKey> = {\n  ref?: Ref<R1>;\n  map?: Key extends 'to' ? Mapper<R1, R2> : Mapper<R2, R1>;\n  watch?: WatchOptions;\n}\n\nexport type CustomBindingOptions<T, R2, Key extends PropertyKey> = {\n  ref: Ref<T>;\n  map: Key extends 'to' ? Mapper<T, R2> : Mapper<R2, T>;\n  watch?: WatchOptions;\n}\n\nexport type SyncedRef<\n  R1,\n  Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Binders<R1, R2, Keys>;\n\ntype _SyncedRef<\n  R1,\n  _Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Partial<Binders<R1, R2, keyof Mappers<R1, R2>>>;\n"],"names":["fromHook","hook","Observable","ctx","getCurrentInstance","pipeUntil","takeUntil","untilUnmounted","onUnmounted","canMergeDeep","state","mutation","key","deepReplaceArray","submutation","defaultOptions","useRxState","initialState","options","mergeKeys","reducers","map$","reactive","callMeMaybe","actions","actions$","actions$Arr","complete","error","context","e","mutations$","Subject","args","mergeScan","prev","curr","isObservable","of","map","tap","merged$","merge","createRxResult","readonly","scan","result","fn","deep","shallow","mapError","cb","catchError","$","setRef","ref","v","fromRef","watch","value","refFrom","arg","subArg","ref$","from","isProxy","toRef","refsFrom","input","defaultValues","next","value$","syncRef","ref1","maps","_ref2","ref2","bind","opts","f","refBase","refDest","dir","bindOptions"],"mappings":"yVAgBa,MAAAA,EAAYC,GAAkB,IAAIC,EAAA,WACtCC,GAAA,CAAEC,EAAAA,mBAAwB,GAAAH,EAAK,IAAME,EAAI,KAAM,CAAA,CAAE,CAC1D,ECJaE,EAAgBJ,GAAkBK,EAAa,UAAAN,EAASC,CAAI,CAAC,EAS7DM,EAAyDF,EAAUG,EAAW,WAAA,ECU9EC,EAAe,CAC1BC,EACAC,EACAC,IAEAD,GAAY,MACT,OAAOA,EAASC,CAAG,GAAM,UACzB,OAAOF,EAAME,CAAG,GAAM,SCzBdC,EACXH,GAEAC,GACG,CACH,UAAWC,KAAOD,EAAU,CACpB,MAAAG,EAAcH,EAASC,CAAG,EAEhCF,EAAME,CAAc,EAAI,CAAC,MAAM,QAAQE,CAAW,GAAKL,EAAaC,EAAOC,EAAUC,CAAG,EACpFC,EAAiBH,EAAME,CAAG,CAAC,EAAEE,CAAW,EACxCA,CACN,CAEO,OAAAJ,CACT,ECdaK,EAAiB,CAC5B,iBAAkBF,CACpB,EAWgB,SAAAG,EACdC,EACAC,EAC8C,CACxC,KAAA,CAAE,iBAAkBC,GAAc,CACtC,GAAGJ,EACH,GAAGG,CAAA,EAGE,OAAA,SAAUE,EAAUC,EAAO,CAKhC,MAAMX,EAAQY,EAAA,SAASC,EAAYN,CAAY,CAAC,EAE1CO,EAAoB,CAAA,EACpBC,EAA4C,CAAA,EAC5CC,EAAgC,CAAA,EAEtC,IAAIC,EAAW,GACXC,EAEJ,MAAMC,EAA2B,CAC/B,MAAYC,GAAA,CAAUF,EAAAE,CAAG,EACzB,SAAU,IAAM,CAAaH,EAAA,EAAM,CAAA,EAGrC,UAAWf,KAAOQ,EAAU,CACpB,MAAAW,EAAa,IAAIC,EAAAA,QAEvBR,EAAQZ,CAAG,EACT,IAAIqB,IAAgBF,EAAW,KAC7BX,EAASR,CAAG,EAAE,MAAMQ,EAAUa,CAAI,CAAA,EAI1BP,EAAA,KACVD,EAAS,GAAGb,IAAe,EACzBsB,YAAU,CAACC,EAASC,KACXA,EAAAb,EAAYa,EAAMD,EAAMN,CAAO,GAGpCQ,eAAaD,CAAI,EACbA,EACAE,EAAA,GAAGF,CAAI,GACX,KACAG,EAAAA,IAAIpB,EAAUgB,EAAMhB,CAAS,CAAC,EAC9BqB,MAAI,CACF,KAAM,IAAMZ,EACRA,EAAQG,EAAW,MAAMH,CAAK,EAC9BD,GAAYI,EAAW,SAAS,CAAA,CACrC,CAAA,GAEFrB,CAAK,EAAEqB,CAAU,CAAA,CAG1B,CAEM,MAAAU,EAAUC,EAAAA,MAAM,GAAGhB,CAAW,EAEpC,OAAOiB,EAAe,CACpB,QAAAnB,EACA,MAAOoB,WAASlC,CAAU,EAC1B,OAAQH,EACNc,EAAOA,EACLoB,EACArB,EACAV,EACAe,EACAI,CAAA,EACA,KACAgB,OAAK,CAACV,EAAMC,IAASjB,EAAUgB,EAAMhB,CAAS,EAAEiB,CAAI,EAAG1B,CAAK,CAAA,EAC1D+B,CACN,EACA,SAAAhB,CAAA,CACD,CAAA,CAEL,CAuCA,MAAMkB,EAA8BG,IAKK,CACvC,GAAGA,EACH,UAAW,IAAIb,KAAiB,CAC9B,GAAGa,EACH,aAAcA,EAAO,OAAO,UAAU,GAAGb,CAAI,CAAA,EAEjD,GAEMV,EAAc,CAClBwB,KACGd,IAEH,OAAOc,GAAO,WACTA,EAAyB,GAAGd,CAAI,EACjCc,ECnIOC,EACXtC,GAEAC,GACG,CACH,UAAWC,KAAOD,EAChBD,EAAME,CAAc,EAAIH,EAAaC,EAAOC,EAAUC,CAAG,EACrDoC,EAAKtC,EAAME,CAAG,CAAC,EAAED,EAASC,CAAG,CAAC,EAC9BD,EAASC,CAAG,EAGX,OAAAF,CACT,EClCauC,EACXvC,GAEAC,GACG,CACH,UAAWC,KAAOD,EACVD,EAAAE,CAAG,EAAID,EAASC,CAAG,EAGpB,OAAAF,CACT,EClBawC,EAAqBC,GAChCC,EAA6B,WAAA,CAACtB,EAAGuB,IAAM,CAAQ,MAAAF,EAAGrB,EAAGuB,CAAC,CAAG,CAAC,ECD/CC,EAAaC,GAAgBf,EAAAA,IAAO,CAAE,KAAWgB,GAAAD,EAAI,MAAQC,CAAG,CAAA,ECsB7D,SAAAC,EAAQF,EAAqDrC,EAA6C,CACjH,OAAAX,EACL,IAAIL,aAAWC,GAAOuD,EAAAA,MAAMH,EAAcI,GAAAxD,EAAI,KAAKwD,CAAK,EAAGzC,CAAO,CAAC,CAAA,CAEvE,CC4DgB,SAAA0C,EAAQC,EAAcC,EAAkB,CACtD,GAAI,OAAOD,GAAQ,SAAc,GAAA,CACzB,MAAAE,EAAOR,MAAIO,CAAM,EAEvB,OAAAvD,EAAeyD,EAAK,KAAAH,CAAU,CAAC,EAAE,UAAU,CACzC,KAAeF,GAAAI,EAAK,MAAQJ,CAAA,CAC7B,EAEMI,QAC+C,CAEjD,OAAAE,EAAA,QAAQJ,CAAG,EACdK,EAAA,MAAML,EAAyBC,CAAM,EACrCP,MAAIM,CAAG,CACb,CCjDO,SAASM,EAASC,EAA6BC,EAAgD,GAAI,CAClG,MAAAC,EAAOf,EAAAA,IAAIc,EAAc,IAAI,EAC7BzC,EAAQ2B,EAAAA,IAAIc,EAAc,KAAK,EAC/BE,EAAShE,EAAeyD,OAAKI,CAAK,CAAC,EAElC,MAAA,CACL,KAAAE,EACA,MAAA1C,EACA,OAAA2C,EACA,aAAcA,EAAO,UAAU,CAC7B,KAAWf,GAAAc,EAAK,MAAQd,EACxB,MAAYA,GAAA5B,EAAM,MAAQ4B,CAAA,CAC3B,CAAA,CAEL,CCXgB,SAAAgB,EAEdC,EACAC,EACAC,EAC2C,CAC3C,MAAMC,EAAOrB,EAAA,IACXoB,IACID,EAAK,GACHA,EAAK,GAAGD,EAAK,KAAK,EAClBA,EAAK,MACP,EAGN,UAAW7D,KAAO8D,GAChBE,EAAKhE,CAAwB,EAAIiE,EAAKJ,EAAMG,EAAMF,EAAM9D,EAAY,IAAI,GACxE,KAAK,EAEA,OAAAgE,CACT,CAEAJ,EAAQ,KAAO,IACVtD,IACgB,CACnB,MAAM4D,EAAO,OAAO,OAAO,CAAA,EAAI,GAAG5D,CAAO,EACnC6D,EAAIP,EAAQ,KAAKM,CAAI,EAC3B,OAAAC,EAAE,KAAOP,EAAQ,KAAK,KAAKM,CAAI,EACxBC,CACT,EAEA,MAAMF,EAAO,CACXG,EACAC,EACAP,EACAQ,EACAhE,KACI,CACJ,KAAOiE,GAAyE,CACxE,KAAA,CACJ,IAAA5B,EAAK,IAAAhB,EAAK,MAAOuC,CAAA,EACe,CAChC,IAAKE,EACL,IAAKN,EAAKQ,CAAG,EACb,MAAOhE,EACP,GAAGiE,CAAA,EAGGF,EAAAC,CAAG,EAAG,OAEdD,EAAQC,CAAG,EAAG,KAAOA,IAAQ,KACzBxB,EAAAA,MAAMH,EAAUC,GAAAyB,EAAQ,MAAQ1C,EAAIiB,CAAC,EAAG,OAAO,OAAO,CAAC,EAAGtC,EAAS4D,CAAI,CAAC,EACxEpB,EAAA,MAAMuB,EAASzB,GAAKD,EAAI,MAAQhB,EAAIiB,CAAC,EAAG,OAAO,OAAO,CAAI,EAAAtC,EAAS4D,CAAI,CAAC,CAC9E,EACA,KAAM,IAAM,CAAC,CACf"}