{"version":3,"file":"umd.js","sources":["../src/hooks/from.ts","../src/operators/until.ts","../src/use-rx/common.ts","../src/use-rx/strategies/deepReplaceArray.ts","../src/use-rx/use-rx-state.ts","../src/rx-refs/sync-ref.ts","../src/use-rx/strategies/deep.ts","../src/rx-refs/from-ref.ts","../src/operators/map-error.ts","../src/rx-refs/ref-from.ts","../src/rx-refs/refs-from.ts","../src/operators/set-ref.ts","../src/use-rx/strategies/shallow.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport { getCurrentInstance } from 'vue';\n\nexport type VueHook = (hook: () => any, ...args: any[]) => any;\n\n/**\n * Creates an observable that emits when a vue hook is executed\n *\n * If subscribed to outside the component scope - equivalent to a NEVER observable\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const fromHook = (hook: VueHook) => new Observable<void>(\n  ctx => { getCurrentInstance() && hook(() => ctx.next()) }\n);\n","import type { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { onUnmounted } from 'vue';\nimport { VueHook, fromHook } from '../hooks/from';\n\n/**\n * Creates an takeUntil that emits when a vue hook is executed\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const pipeUntil = <T>(hook: VueHook) => takeUntil<T>(fromHook(hook));\n\n/**\n * Stops an observable when a vue component is unmounted\n *\n * @param $ - obserable to stop on unmounted\n *\n * ---\n */\nexport const untilUnmounted: <T>($: Observable<T>) => Observable<T> = pipeUntil(onUnmounted);\n","import { Ref, UnwrapRef } from 'vue';\n\nexport type Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>;\n\nexport type MutationStrategy<S extends Record<PropertyKey, any>, M> = {\n  /**\n   * Creates a mutation applier\n   *\n   * @param state - a base state to mutate\n   * @param strategy - current mutation strategy\n   */\n  (state: S, strategy: MutationStrategy<S, M>): (mutation: M) => S;\n};\n\n/**\n * Checks if it's possible to advance deeper\n * into the sibling object structures,\n * with one being partial\n *\n * @param state - the object source\n * @param mutation - the main checking reference\n * @param key - a key into which to advance\n */\n export const canMergeDeep = <S extends Record<PropertyKey, any>, Mutation extends Record<keyof S, any>>(\n  state: S,\n  mutation: Mutation | null | undefined,\n  key: keyof S,\n) => (\n  mutation != null\n  && typeof mutation[key] === 'object'\n  && typeof state[key] === 'object'\n);\n","import { Builtin, canMergeDeep } from '../common';\n\nexport type DeepReplaceArrayMutation<T> = T extends Builtin | Array<any> | ReadonlyArray<any>\n  ? T\n  : T extends Record<any, any>\n  ? { [K in keyof Partial<T>]: DeepReplaceArrayMutation<T[K]> }\n  : Partial<T>;\n\n/**\n * Default merge strategy for mutations\n *\n * Deep-merges state and mutation objects recursively,\n * by enumerable keys (`for..in`),\n * but replaces arrays and primitives\n */\n export const deepReplaceArray = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepReplaceArrayMutation<S>\n) => {\n  for (const key in mutation) {\n    const submutation = mutation[key];\n\n    state[key as keyof S] = !Array.isArray(submutation) && canMergeDeep(state, mutation, key)\n      ? deepReplaceArray(state[key])(submutation)\n      : submutation as S[keyof S];\n  }\n\n  return state;\n};\n","import type { Observable, PartialObserver, Subscription } from 'rxjs';\nimport type { DeepReadonly } from 'vue';\n\nimport { isObservable, merge, of, Subject } from 'rxjs';\nimport { map, mergeScan, scan, tap } from 'rxjs/operators';\nimport { reactive, readonly } from 'vue';\nimport { untilUnmounted } from '../operators/until';\nimport { MutationStrategy, UnwrapNestedRefs } from './common';\nimport { deepReplaceArray, DeepReplaceArrayMutation } from './strategies/deepReplaceArray';\n\n\nexport interface RxStateOptions<S extends Record<PropertyKey, any>, Mutaiton> {\n  mutationStrategy: MutationStrategy<S, Mutaiton>;\n}\n\nconst defaultOptions = {\n  mutationStrategy: deepReplaceArray,\n};\n\n/**\n * Allows to bind reducers to a state and an observable.\n *\n * First accepts state's default value and a state merge strategy,\n * then accepts a map of state reducers.\n *\n * @param initialState - a factory or initial value for the reactive state\n * @param options - options to customize the behavior, for example - to apply a custom strategy of merging a mutation with an old state\n */\nexport function useRxState<T extends Record<PropertyKey, any>, Mutation = DeepReplaceArrayMutation<UnwrapNestedRefs<T>>>(\n  initialState: T | (() => T),\n  options?: Partial<RxStateOptions<UnwrapNestedRefs<T>, Mutation>>\n): CreateRxState<UnwrapNestedRefs<T>, Mutation> {\n  const { mutationStrategy: mergeKeys } = {\n    ...defaultOptions as RxStateOptions<UnwrapNestedRefs<T>, Mutation>,\n    ...options\n  };\n\n  return function (reducers, map$?) {\n    type S = UnwrapNestedRefs<T>;\n    type ReducerResult = ReturnType<StateReducer<S, Mutation>>;\n    type Actions = ReducerActions<typeof reducers>;\n\n    const state = reactive(maybeCall(initialState));\n\n    const actions = <Actions> {};\n    const actions$ = <ReducerObservables<Actions, S>> {};\n    const actions$Arr = <Observable<S>[]> [];\n\n    let complete = false;\n    let error: any = undefined;\n\n    const context: MutationContext = {\n      error: e => { error = e; },\n      complete: () => { complete = true; }\n    };\n\n    for (const key in reducers) {\n      const mutations$ = new Subject<ReducerResult>();\n\n      actions[key] = <ReducerAction<typeof reducers[typeof key]>>(\n        (...args: any[]) => mutations$.next(\n          reducers[key].apply(reducers, args)\n        )\n      );\n\n      actions$Arr.push(\n        actions$[`${key}$` as const] = (\n          mergeScan((prev: S, curr: ReducerResult) => {\n            curr = maybeCall(curr, prev, context);\n\n            return (\n              isObservable(curr)\n                ? curr\n                : of(curr)\n            ).pipe(\n              map(mergeKeys(prev, mergeKeys)),\n              tap({\n                next: () => error\n                  ? error = mutations$.error(error)\n                  : complete && mutations$.complete()\n              })\n            )\n          }, state)(mutations$)\n        )\n      );\n    }\n\n    const merged$ = merge(...actions$Arr);\n\n    return createRxResult({\n      actions,\n      state: readonly(state as T),\n      state$: untilUnmounted(\n        map$ ? map$(\n          merged$,\n          reducers,\n          state,\n          actions$,\n          context,\n        ).pipe(\n          scan((prev, curr) => mergeKeys(prev, mergeKeys)(curr), state)\n        ) : merged$\n      ),\n      actions$: actions$ as ReducerObservables<Actions, DeepReadonly<S>>,\n    });\n  };\n}\n\ntype CreateRxState<S, Mutation> = {\n  /**\n   * Allows to bind reducers to a state and an observable.\n   *\n   * Accepts a map of state reducers.\n   *\n   * Each reducer can either return:\n   * * an updated part of the state:\n   *   ```\n   *   (v) => ({ value: v })\n   *   ```\n   * * an observable that emits an updated part of the state:\n   *   ```\n   *   (v) => new BehaviorSubject({ value: v })\n   *   ```\n   * * a function that accepts the old state and returns either of the previous types:\n   *   ```\n   *   (v) => (oldState) => ({\n   *       value: oldState.value > v ? oldState.value : v\n   *   })\n   *   ```\n   *\n   * @param reducers a map of reducers to mutate the state\n   * @param map$ a function to modify the resulting observable\n   */\n  <R extends StateReducers<S, Mutation>>(\n    reducers: R,\n    map$?: (\n      state$: Observable<S>,\n      reducers: R,\n      state: S,\n      actions$: Record<Action$<Extract<keyof R, string>>, Observable<S>>,\n      context: MutationContext\n    ) => Observable<Mutation>\n  ): SubscribableRxResult<ReducerActions<R>, S>;\n};\n\nconst createRxResult = <S, Actions>(result: {\n  actions: Actions,\n  state: DeepReadonly<S>,\n  state$: Observable<S>,\n  actions$: ReducerObservables<Actions, DeepReadonly<S>>\n}): SubscribableRxResult<Actions, S> => ({\n  ...result,\n  subscribe: (...args: any[]) => ({\n    ...result,\n    subscription: result.state$.subscribe(...args),\n  }),\n})\n\nconst maybeCall = <T, A extends any[]>(\n  fn: T | ((...args: A) => T),\n  ...args: A\n) => (\n  typeof fn === 'function'\n    ? (fn as (...args: A) => T)(...args)\n    : fn\n);\n\nexport interface MutationContext {\n  error(error: any): void;\n  complete(): void;\n}\n\nexport type StatefulMutation<S, Mutation> = (state: S, mutation?: MutationContext) => Mutation | Observable<Mutation>;\n\n/**\n * A reducer for the observable state\n */\nexport type StateReducer<S, Mutation, Args extends any[] = any[]> = (\n  (...args: Args) =>\n    | Mutation\n    | Observable<Mutation>\n    | StatefulMutation<S, Mutation>\n);\n\n/**\n * A named collection of state reducers\n */\nexport type StateReducers<S, Mutation> = Record<string, StateReducer<S, Mutation>>;\n\n/**\n * A method action generated from a StateReducer\n */\nexport type ResAction<A extends any[] = []> = (...args: A) => void;\n\ntype Action$<Name extends string> = `${Name}$`;\n\ntype ReducerObservables<H, R> = {\n  [key in Action$<Extract<keyof H, string>>]: Observable<R>;\n};\n\n/**\n * Resulting RX bindings:\n *\n * * actions - a named collection of ResAction-s\n * * state - a reactive vue state\n * * state$ - an rxjs observable\n */\nexport interface RxResult<Actions, State> {\n  readonly actions: Actions;\n  readonly state: DeepReadonly<State>;\n  readonly state$: Observable<State>;\n  readonly actions$: ReducerObservables<Actions, DeepReadonly<State>>;\n};\n\nexport interface SubscribableRxResult<Actions, State> extends RxResult<Actions, State> {\n  readonly subscribe: {\n    (observer?: PartialObserver<State>): SubscriptionRxResult<Actions, State>;\n    (...args: Parameters<Observable<State>['subscribe']>): SubscriptionRxResult<Actions, State>;\n  };\n};\n\nexport interface SubscriptionRxResult<Actions, State> extends RxResult<Actions, State> {\n  readonly subscription: Subscription;\n}\n\ntype ReducerAction<R> = R extends StateReducer<any, any, infer Args>\n  ? ResAction<Args>\n  : never;\n\ntype ReducerActions<R> = { [key in keyof R]: ReducerAction<R[key]> };\n","import { Ref, UnwrapRef, ref, watch, WatchOptions, WatchStopHandle } from 'vue';\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto the first.\n */\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to }: { to: Mapper<R1, UnwrapRef<R2>> },\n): SyncedRef<R1, 'to', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { from }: { from: Mapper<UnwrapRef<R2>, R1> },\n  defaultValue?: R2,\n): SyncedRef<R1, 'from', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: { to: Mapper<R1, UnwrapRef<R2>>, from: Mapper<UnwrapRef<R2>, R1> },\n): SyncedRef<R1, 'to' | 'from', UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto the first.\n */\n export function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  defaultValue?: R2,\n): SyncedRef<R1, keyof M, UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The second ref serves as an origin point for the binding,\\\n * values **from** the second ref and **to** the second ref are mapped onto the first.\n */\nexport function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  ref2: Ref<R2>,\n): SyncedRef<R1, keyof M, R2>;\n\nexport function syncRef<R1, R2>(\n  this: WatchOptions,\n  ref1: Ref<R1>,\n  maps: Mappers<R1, R2>,\n  _ref2?: Ref<R2> | R2,\n): _SyncedRef<R1, keyof Mappers<R1, R2>, R2> {\n  const ref2 = ref(\n    _ref2 == null\n      ? maps.to\n        ? maps.to(ref1.value)\n        : ref1.value\n      : _ref2\n  ) as _SyncedRef<R1, keyof Mappers<R1, R2>, R2>;\n\n  for (const key in maps) (\n    ref2[key as keyof typeof maps] = bind(ref1, ref2, maps, key as any, this)\n  ).bind();\n\n  return ref2;\n}\n\nsyncRef.with = <T extends Readonly<boolean> = false>(\n  ...options: WatchOptions<T>[]\n): typeof syncRef => {\n  const opts = Object.assign({}, ...options);\n  const f = syncRef.bind(opts);\n  f.with = syncRef.with.bind(opts);\n  return f;\n}\n\nconst bind = <R1, R2>(\n  refBase: Ref<R1>,\n  refDest: _SyncedRef<R1, keyof Mappers<R1, R2>, R2>,\n  maps: Mappers<R1, R2>,\n  dir: keyof Mappers<R1, R2>,\n  options: WatchOptions,\n) => ({\n  bind: (bindOptions?: Partial<BindingOptions<R1, R2, keyof Mappers<R1, R2>>>) => {\n    const {\n      ref, map, watch: opts\n    }: BindingOptions<any, R2, any> = {\n      ref: refBase,\n      map: maps[dir]!,\n      watch: options,\n      ...bindOptions,\n    };\n\n    refDest[dir]!.stop();\n\n    refDest[dir]!.stop = dir === 'to'\n      ? watch(ref, v => refDest.value = map(v), Object.assign({}, options, opts))\n      : watch(refDest, v => ref.value = map(v), Object.assign({}, options, opts));\n  },\n  stop: () => {}\n});\n\ntype Mapper<F, T> = (value: F) => T;\n\ntype Mappers<R1, R2> = {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from?: never,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to?: never,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n};\n\ntype Binders<R1, R2, Keys extends PropertyKey> = {\n  [key in Keys]: {\n    /**\n     * Cut the binding in this direction\n     */\n    stop: WatchStopHandle;\n    bind: {\n      /**\n       * Reapply the binding in this direction\n       */\n      (): void;\n\n      /**\n       * Bind this direction to a new ref\n       */\n      (options?: BindingOptions<R1, R2, key>): void;\n\n      /**\n       * Bind this direction to a new ref with a new map\n       */\n      <T>(options: CustomBindingOptions<T, R2, key>): void;\n    };\n  };\n};\n\ntype BindingOptions<R1, R2, Key extends PropertyKey> = {\n  ref?: Ref<R1>;\n  map?: Key extends 'to' ? Mapper<R1, R2> : Mapper<R2, R1>;\n  watch?: WatchOptions;\n}\n\ntype CustomBindingOptions<T, R2, Key extends PropertyKey> = {\n  ref: Ref<T>;\n  map: Key extends 'to' ? Mapper<T, R2> : Mapper<R2, T>;\n  watch?: WatchOptions;\n}\n\ntype SyncedRef<\n  R1,\n  Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Binders<R1, R2, Keys>;\n\ntype _SyncedRef<\n  R1,\n  _Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Partial<Binders<R1, R2, keyof Mappers<R1, R2>>>;\n","import { canMergeDeep } from '../common';\n\nexport type Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type DeepMutation<T> = T extends Builtin\n  ? T\n  : T extends Array<infer U>\n  ? Array<DeepMutation<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepMutation<U>>\n  : T extends Record<any, any>\n  ? { [K in keyof Partial<T>]: DeepMutation<T[K]> }\n  : Partial<T>;\n\n/**\n * A deep-merge strategy for mutations\n *\n * Deep-merges state and mutation recursively,\n * by enumerable keys (`for..in`),\n * so avoid recursive object links\n */\nexport const deep = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepMutation<S>\n) => {\n  for (const key in mutation) {\n    state[key as keyof S] = canMergeDeep(state, mutation, key)\n      ? deep(state[key])(mutation[key])\n      : mutation[key] as S[keyof S];\n  }\n\n  return state;\n};\n","import { Observable } from 'rxjs';\nimport { watch, WatchOptions, WatchSource } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\n/**\n * Creates an observable from a vue ref.\n *\n * Each time a ref's value is changed - observable emits.\n *\n * Can also accept vue reactive objects and value factories.\n *\n * @param ref - a ref/reactive/factory to observe\n * @returns an observable that watches the ref\n */\nexport function fromRef<R>(ref: WatchSource<R>, options?: WatchOptions): Observable<R>;\n\n/**\n * Creates an observable from a vue reactive state.\n *\n * Each time a state's value is changed - observable emits.\n *\n * @param ref - a reactive state to observe\n * @returns an observable that watches the state\n */\nexport function fromRef<R extends Record<string, any>>(reactiveState: R, options?: WatchOptions): Observable<R>;\nexport function fromRef(ref: Record<string, unknown> | WatchSource<unknown>): Observable<unknown> {\n  return untilUnmounted(\n    new Observable(ctx => watch(ref, value => ctx.next(value)))\n  );\n};\n","import { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport const mapError = <T, O, R>(cb: (e: T, $: Observable<O>) => R) => (\n  catchError<O, Observable<O>>((e, $) => { throw cb(e, $); })\n);\n","import { from, ObservableInput } from 'rxjs';\nimport { isProxy, Ref, ref, toRef, UnwrapRef } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is resolved, the ref is set to the resulting value.\n *\n * The ref will contain `undefined` until the promise is resolved.\n *\n * @param promise to set from\n */\nexport function refFrom<R>(promise: Promise<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is fulfilled, the ref is set to the resulting value.\n * Until then, the ref will contain the passed default value.\n *\n * @param promise to set from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(promise: Promise<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: R): Ref<UnwrapRef<R>>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n *\n * The ref will contain `undefined` until the observable emits.\n *\n * @param observableInput an input to create an observable form and then listen to it\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n * Until then, the ref will contain the passed default value.\n *\n * @param observableInput an input to create an observable form and then listen to it\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * Works exactly like toRef:\n * creates a ref from a reactive state.\n *\n * @param state a reactive state to bind from\n * @param key a key of the state to bind\n */\nexport function refFrom<R extends Record<any, any>, K extends keyof R>(state: R, key: K): Ref<UnwrapRef<R[K]>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R, defaultValue: R): Ref<UnwrapRef<R>>;\n\nexport function refFrom(arg: unknown, subArg?: unknown) {\n  if (typeof arg === 'object') try {\n    const ref$ = ref(subArg);\n\n    untilUnmounted(from(arg as any)).subscribe({\n      next: value => ref$.value = value\n    });\n\n    return ref$;\n  } catch (_) { /* Silence the error to try another ways */ }\n\n  return isProxy(arg)\n    ? toRef(arg as Record<any, any>, subArg)\n    : ref(arg);\n}\n","import { ObservableInput, from, Subscription, Observable } from 'rxjs';\nimport { Ref, ref } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\ntype Subscribers<R, E> = { next: R; error: E; };\n\ntype Refs<R, E> = {\n  [key in keyof Subscribers<R, E>]: Ref<Subscribers<R, E>[key]>;\n} & {\n  subscription: Subscription;\n  value$: Observable<R>;\n};\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * Until the observable emits, the refs will contain `undefined`.\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>): Refs<R | undefined, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>, defaultValues: { next: R }): Refs<R, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E>(input: ObservableInput<R>, defaultValues: Subscribers<R, E>): Refs<R, E>;\n\nexport function refsFrom(input: ObservableInput<any>, defaultValues: Partial<Subscribers<any, any>> = {}) {\n  const next = ref(defaultValues.next);\n  const error = ref(defaultValues.error);\n  const value$ = untilUnmounted(from(input));\n\n  return {\n    next,\n    error,\n    value$,\n    subscription: value$.subscribe({\n      next: v => next.value = v,\n      error: v => error.value = v,\n    })\n  };\n}\n","import { tap } from 'rxjs/operators';\nimport { Ref } from 'vue';\n\nexport const setRef = <T>(ref: Ref<T>) => tap<T>({ next: v => ref.value = v });\n","export type ShallowMutation<S> = {\n  // Hack to avoid double `undefined` in `[key]?: value | undefined`\n  [K in keyof Partial<S>]: S[K];\n};\n\n/**\n * A merge strategy for mutations\n *\n * Shallow-merges state and mutation recursively,\n * by enumerable keys (`for..in`)\n */\n export const shallow = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: ShallowMutation<S>\n) => {\n  for (const key in mutation) {\n    state[key] = mutation[key];\n  }\n\n  return state;\n};\n"],"names":["fromHook","hook","Observable","ctx","getCurrentInstance","next","pipeUntil","takeUntil","untilUnmounted","onUnmounted","canMergeDeep","state","mutation","key","_typeof","deepReplaceArray","submutation","Array","isArray","defaultOptions","mutationStrategy","createRxResult","result","subscribe","subscription","state$","maybeCall","fn","args","syncRef","ref1","maps","_ref2","ref2","ref","to","value","bind","this","options","opts","Object","assign","f","refBase","refDest","dir","bindOptions","map","watch","stop","v","deep","cb","catchError","e","$","arg","subArg","ref$","from","_","isProxy","toRef","input","defaultValues","error","value$","tap","initialState","mergeKeys","reducers","map$","reactive","actions","actions$","actions$Arr","complete","undefined","context","mutations$","Subject","apply","push","mergeScan","prev","curr","isObservable","of","pipe","merged$","merge","readonly","scan"],"mappings":"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"}