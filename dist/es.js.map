{"version":3,"file":"es.js","sources":["../src/hooks/from.ts","../src/operators/until.ts","../src/use-rx/common.ts","../src/use-rx/strategies/deepReplaceArray.ts","../src/use-rx/use-rx-state.ts","../src/use-rx/strategies/deep.ts","../src/use-rx/strategies/shallow.ts","../src/operators/map-error.ts","../src/operators/set-ref.ts","../src/rx-refs/from-ref.ts","../src/rx-refs/ref-from.ts","../src/rx-refs/refs-from.ts","../src/rx-refs/sync-ref.ts","../src/hooks/use-subscription.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport { getCurrentInstance } from 'vue';\n\nexport type VueHook = (hook: () => any, ...args: any[]) => any;\n\n/**\n * Creates an observable that emits when a vue hook is executed\n *\n * If subscribed to outside the component scope - equivalent to a NEVER observable\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const fromHook = (hook: VueHook) => new Observable<void>(\n  ctx => { getCurrentInstance() && hook(() => ctx.next()) }\n);\n","import type { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { onUnmounted } from 'vue';\nimport { VueHook, fromHook } from '../hooks/from';\n\n/**\n * Creates an takeUntil that emits when a vue hook is executed\n *\n * @param hook the vue hook to listen to\n *\n * for example: onUnmounted, onActivated, onUpdated, etc.\n *\n * ---\n */\nexport const pipeUntil = <T>(hook: VueHook) => takeUntil<T>(fromHook(hook));\n\n/**\n * Stops an observable when a vue component is unmounted\n *\n * @param $ - obserable to stop on unmounted\n *\n * ---\n */\nexport const untilUnmounted: <T>($: Observable<T>) => Observable<T> = pipeUntil(onUnmounted);\n","export type Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type MutationStrategy<S extends Record<PropertyKey, any>, M> = {\n  /**\n   * Creates a mutation applier\n   *\n   * @param state - a base state to mutate\n   * @param strategy - current mutation strategy\n   */\n  (state: S, strategy: MutationStrategy<S, M>): (mutation: M) => S;\n};\n\n/**\n * Checks if it's possible to advance deeper\n * into the sibling object structures,\n * with one being partial\n *\n * @param state - the object source\n * @param mutation - the main checking reference\n * @param key - a key into which to advance\n */\nexport const canMergeDeep = <S extends Record<PropertyKey, any>, Mutation extends Record<keyof S, any>>(\n  state: S,\n  mutation: Mutation | null | undefined,\n  key: keyof S,\n) => (\n  mutation != null\n  && typeof mutation[key] === 'object'\n  && typeof state[key] === 'object'\n);\n","import { Builtin, canMergeDeep } from '../common';\n\nexport type DeepReplaceArrayMutation<T> = T extends Builtin | Array<any> | ReadonlyArray<any>\n  ? T\n  : T extends Record<any, any>\n  ? { [K in keyof Partial<T>]: DeepReplaceArrayMutation<T[K]> }\n  : Partial<T>;\n\n/**\n * Default merge strategy for mutations\n *\n * Deep-merges state and mutation objects recursively,\n * by enumerable keys (`for..in`),\n * but replaces arrays and primitives\n */\nexport const deepReplaceArray = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepReplaceArrayMutation<S>\n) => {\n  for (const key in mutation) {\n    const submutation = mutation[key];\n\n    state[key as keyof S] = !Array.isArray(submutation) && canMergeDeep(state, mutation, key)\n      ? deepReplaceArray(state[key])(submutation)\n      : submutation as S[keyof S];\n  }\n\n  return state;\n};\n","import type { Observable, PartialObserver, Subscription } from 'rxjs';\nimport type { DeepReadonly, UnwrapNestedRefs } from 'vue';\n\nimport { isObservable, merge, of, Subject } from 'rxjs';\nimport { map, mergeScan, scan, tap } from 'rxjs/operators';\nimport { reactive, readonly } from 'vue';\nimport { untilUnmounted } from '../operators/until';\nimport { MutationStrategy } from './common';\nimport { deepReplaceArray, DeepReplaceArrayMutation } from './strategies/deepReplaceArray';\n\n\nexport interface RxStateOptions<S extends Record<PropertyKey, any>, Mutaiton> {\n  mutationStrategy: MutationStrategy<S, Mutaiton>;\n}\n\nexport const defaultOptions = {\n  mutationStrategy: deepReplaceArray,\n};\n\n/**\n * Allows to bind reducers to a state and an observable.\n *\n * First accepts state's default value and a state merge strategy,\n * then accepts a map of state reducers.\n *\n * @param initialState - a factory or initial value for the reactive state\n * @param options - options to customize the behavior, for example - to apply a custom strategy of merging a mutation with an old state\n */\nexport function useRxState<T extends Record<PropertyKey, any>, Mutation = DeepReplaceArrayMutation<UnwrapNestedRefs<T>>>(\n  initialState: T | (() => T),\n  options?: Partial<RxStateOptions<UnwrapNestedRefs<T>, Mutation>>\n): CreateRxState<UnwrapNestedRefs<T>, Mutation> {\n  const { mutationStrategy: mergeKeys } = {\n    ...defaultOptions as RxStateOptions<UnwrapNestedRefs<T>, Mutation>,\n    ...options\n  };\n\n  return function (reducers, map$?) {\n    type S = UnwrapNestedRefs<T>;\n    type ReducerResult = ReturnType<StateReducer<S, Mutation>>;\n    type Actions = ReducerActions<typeof reducers>;\n\n    const state = reactive(callMeMaybe(initialState));\n\n    const actions = <Actions> {};\n    const actions$ = <ReducerObservables<Actions, S>> {};\n    const actions$Arr = <Observable<S>[]> [];\n\n    let complete = false;\n    let error: any = undefined;\n\n    const context: MutationContext = {\n      error: e => { error = e; },\n      complete: () => { complete = true; }\n    };\n\n    for (const key in reducers) {\n      const mutations$ = new Subject<ReducerResult>();\n\n      actions[key] = <ReducerAction<typeof reducers[typeof key]>>(\n        (...args: any[]) => mutations$.next(\n          reducers[key].apply(reducers, args)\n        )\n      );\n\n      actions$Arr.push(\n        actions$[`${key}$` as const] = (\n          mergeScan((prev: S, curr: ReducerResult) => {\n            curr = callMeMaybe(curr, prev, context);\n\n            return (\n              isObservable(curr)\n                ? curr\n                : of(curr)\n            ).pipe(\n              map(mergeKeys(prev, mergeKeys)),\n              tap({\n                next: () => error\n                  ? error = mutations$.error(error)\n                  : complete && mutations$.complete()\n              })\n            )\n          }, state)(mutations$)\n        )\n      );\n    }\n\n    const merged$ = merge(...actions$Arr);\n\n    return createRxResult({\n      actions,\n      state: readonly(state as T),\n      state$: untilUnmounted(\n        map$ ? map$(\n          merged$,\n          reducers,\n          state,\n          actions$,\n          context,\n        ).pipe(\n          scan((prev, curr) => mergeKeys(prev, mergeKeys)(curr), state)\n        ) : merged$\n      ),\n      actions$: actions$ as ReducerObservables<Actions, DeepReadonly<S>>,\n    });\n  };\n}\n\n/**\n * Extracts state type from the result of the first useRxState call,\n * so that the state type can be defined declaratively from the object itself to use later.\n *\n * @example ```ts\n * const countState = useRxState({ count: 0 });\n * type CountState = State<typeof countState>;\n * // CountState = { count: number }\n * ```\n */\nexport type State<C extends CreateRxState<any, any>> = C extends CreateRxState<infer S, any> ? S : never;\n\ntype CreateRxState<S, Mutation> = {\n  /**\n   * Allows to bind reducers to a state and an observable.\n   *\n   * Accepts a map of state reducers.\n   *\n   * Each reducer can either return:\n   * * an updated part of the state:\n   *   ```\n   *   (v) => ({ value: v })\n   *   ```\n   * * an observable that emits an updated part of the state:\n   *   ```\n   *   (v) => new BehaviorSubject({ value: v })\n   *   ```\n   * * a function that accepts the old state and returns either of the previous types:\n   *   ```\n   *   (v) => (oldState) => ({\n   *       value: oldState.value > v ? oldState.value : v\n   *   })\n   *   ```\n   *\n   * @param reducers a map of reducers to mutate the state\n   * @param map$ a function to modify the resulting observable\n   */\n  <R extends StateReducers<S, Mutation>>(\n    reducers: R,\n    map$?: (\n      state$: Observable<S>,\n      reducers: R,\n      state: S,\n      actions$: Record<Action$<Extract<keyof R, string>>, Observable<S>>,\n      context: MutationContext\n    ) => Observable<Mutation>\n  ): SubscribableRxResult<ReducerActions<R>, S>;\n};\n\nconst createRxResult = <S, Actions>(result: {\n  actions: Actions,\n  state: DeepReadonly<S>,\n  state$: Observable<S>,\n  actions$: ReducerObservables<Actions, DeepReadonly<S>>\n}): SubscribableRxResult<Actions, S> => ({\n  ...result,\n  subscribe: (...args: any[]) => ({\n    ...result,\n    subscription: result.state$.subscribe(...args),\n  }),\n})\n\nconst callMeMaybe = <T, A extends any[]>(\n  fn: T | ((...args: A) => T),\n  ...args: A\n) => (\n  typeof fn === 'function'\n    ? (fn as (...args: A) => T)(...args)\n    : fn\n);\n\nexport interface MutationContext {\n  error(error: any): void;\n  complete(): void;\n}\n\nexport type StatefulMutation<S, Mutation> = (state: S, mutation?: MutationContext) => Mutation | Observable<Mutation>;\n\n/**\n * A general type for a reducer of the observable state\n */\nexport type StateReducer<S, Mutation = DeepReplaceArrayMutation<S>, Args extends any[] = any[]> = (\n  (...args: Args) =>\n    | Mutation\n    | Observable<Mutation>\n    | StatefulMutation<S, Mutation>\n);\n\n/**\n * A simple stateful reducer type that is returned by a stateful reducer upon the first call\n */\nexport type SimpleReducer<S> = (state: S) => Partial<S>;\n\n/**\n * A named collection of state reducers\n */\nexport type StateReducers<S, Mutation> = Record<string, StateReducer<S, Mutation>>;\n\n/**\n * A method action generated from a StateReducer\n */\nexport type ResAction<A extends any[] = []> = (...args: A) => void;\n\ntype Action$<Name extends string> = `${Name}$`;\n\ntype ReducerObservables<H, R> = {\n  [key in Action$<Extract<keyof H, string>>]: Observable<R>;\n};\n\n/**\n * Resulting RX bindings:\n *\n * * actions - a named collection of ResAction-s\n * * state - a reactive vue state\n * * state$ - an rxjs observable\n */\nexport interface RxResult<Actions, State> {\n  readonly actions: Actions;\n  readonly state: DeepReadonly<State>;\n  readonly state$: Observable<State>;\n  readonly actions$: ReducerObservables<Actions, DeepReadonly<State>>;\n};\n\nexport interface SubscribableRxResult<Actions, State> extends RxResult<Actions, State> {\n  readonly subscribe: {\n    (observer?: PartialObserver<State>): SubscriptionRxResult<Actions, State>;\n    (...args: Parameters<Observable<State>['subscribe']>): SubscriptionRxResult<Actions, State>;\n  };\n};\n\nexport interface SubscriptionRxResult<Actions, State> extends RxResult<Actions, State> {\n  readonly subscription: Subscription;\n}\n\ntype ReducerAction<R> = R extends StateReducer<any, any, infer Args>\n  ? ResAction<Args>\n  : never;\n\ntype ReducerActions<R> = { [key in keyof R]: ReducerAction<R[key]> };\n","import { canMergeDeep } from '../common';\n\nexport type Builtin =\n  | Function\n  | Date\n  | Error\n  | RegExp\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type DeepMutation<T> = T extends Builtin\n  ? T\n  : T extends Array<infer U>\n  ? Array<DeepMutation<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepMutation<U>>\n  : T extends Record<any, any>\n  ? { [K in keyof Partial<T>]: DeepMutation<T[K]> }\n  : Partial<T>;\n\n/**\n * A deep-merge strategy for mutations\n *\n * Deep-merges state and mutation recursively,\n * by enumerable keys (`for..in`),\n * so avoid recursive object links\n */\nexport const deep = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: DeepMutation<S>\n) => {\n  for (const key in mutation) {\n    state[key as keyof S] = canMergeDeep(state, mutation, key)\n      ? deep(state[key])(mutation[key])\n      : mutation[key] as S[keyof S];\n  }\n\n  return state;\n};\n","export type ShallowMutation<S> = {\n  // Hack to avoid double `undefined` in `[key]?: value | undefined`\n  [K in keyof Partial<S>]: S[K];\n};\n\n/**\n * A merge strategy for mutations\n *\n * Shallow-merges state and mutation recursively,\n * by enumerable keys (`for..in`)\n */\nexport const shallow = <S extends Record<PropertyKey, any>>(\n  state: S\n) => (\n  mutation: ShallowMutation<S>\n) => {\n  for (const key in mutation) {\n    state[key] = mutation[key];\n  }\n\n  return state;\n};\n","import { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport const mapError = <T, O, R>(cb: (e: T, $: Observable<O>) => R) => (\n  catchError<O, Observable<O>>((e, $) => { throw cb(e, $); })\n);\n","import { tap } from 'rxjs/operators';\nimport { Ref } from 'vue';\n\nexport const setRef = <T>(ref: Ref<T>) => tap<T>({ next: v => ref.value = v });\n","import { Observable } from 'rxjs';\nimport { watch, WatchOptions, WatchSource } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\n/**\n * Creates an observable from a vue ref.\n *\n * Each time a ref's value is changed - observable emits.\n *\n * Can also accept vue reactive objects and value factories.\n *\n * @param ref - a ref/reactive/factory to observe\n * @returns an observable that watches the ref\n */\nexport function fromRef<R>(ref: WatchSource<R>, options?: WatchOptions): Observable<R>;\n\n/**\n * Creates an observable from a vue reactive state.\n *\n * Each time a state's value is changed - observable emits.\n *\n * @param ref - a reactive state to observe\n * @returns an observable that watches the state\n */\nexport function fromRef<R extends Record<string, any>>(reactiveState: R, options?: WatchOptions): Observable<R>;\nexport function fromRef(ref: Record<string, unknown> | WatchSource<unknown>, options?: WatchOptions): Observable<unknown> {\n  return untilUnmounted(\n    new Observable(ctx => watch(ref, value => ctx.next(value), options))\n  );\n};\n","import { from, ObservableInput } from 'rxjs';\nimport { isProxy, Ref, ref, toRef, UnwrapRef } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is resolved, the ref is set to the resulting value.\n *\n * The ref will contain `undefined` until the promise is resolved.\n *\n * @param promise to set from\n */\nexport function refFrom<R>(promise: Promise<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from a promise.\n *\n * Once a promise is fulfilled, the ref is set to the resulting value.\n * Until then, the ref will contain the passed default value.\n *\n * @param promise to set from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(promise: Promise<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: R): Ref<UnwrapRef<R>>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n *\n * The ref will contain `undefined` until the observable emits.\n *\n * @param observableInput an input to create an observable form and then listen to it\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * Creates a ref from an observable input.\n *\n * Behaves exactly like `from` in rxjs and creates an observable from the input.\n *\n * Once a resulting observable emits, the ref is set to the emitted value.\n * Until then, the ref will contain the passed default value.\n *\n * @param observableInput an input to create an observable form and then listen to it\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(obserableInput: ObservableInput<R>, defaultValue: R): Ref<UnwrapRef<R>>;\n\n/**\n * Works exactly like toRef:\n * creates a ref from a reactive state.\n *\n * @param state a reactive state to bind from\n * @param key a key of the state to bind\n */\nexport function refFrom<R extends Record<any, any>, K extends keyof R>(state: R, key: K): Ref<UnwrapRef<R[K]>>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R): Ref<UnwrapRef<R> | undefined>;\n\n/**\n * `refFrom` is not supposed to work for dynamic types and is recommended to use statically!\n *\n * But this overload is still allowed as a convenience.\n *\n * @param value a value to create the ref from\n * @param defaultValue to set to the ref initially\n */\nexport function refFrom<R>(arg: ObservableInput<R> | R, defaultValue: R): Ref<UnwrapRef<R>>;\n\nexport function refFrom(arg: unknown, subArg?: unknown) {\n  if (typeof arg === 'object' && !isProxy(arg)) try {\n    const ref$ = ref(subArg);\n\n    untilUnmounted(from(arg as any)).subscribe({\n      next: value => ref$.value = value\n    });\n\n    return ref$;\n  } catch (_) { /* Silence the error to try other ways */ }\n\n  return isProxy(arg)\n    ? toRef(arg as Record<any, any>, subArg)\n    : ref(arg);\n}\n","import { ObservableInput, from, Subscription, Observable } from 'rxjs';\nimport { Ref, ref } from 'vue';\nimport { untilUnmounted } from '../operators/until';\n\ntype Subscribers<R, E> = { next: R; error: E; };\n\ntype Refs<R, E> = {\n  [key in keyof Subscribers<R, E>]: Ref<Subscribers<R, E>[key]>;\n} & {\n  subscription: Subscription;\n  value$: Observable<R>;\n};\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * Until the observable emits, the refs will contain `undefined`.\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>): Refs<R | undefined, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E = unknown>(input: ObservableInput<R>, defaultValues: { next: R }): Refs<R, E | undefined>;\n\n/**\n * Creates two refs from an observable input (promise, iterable, observable and alike):\n * - `next` - is set when the resulting observable resolves\n * - `error` - is set when the resulting observable errors\n *\n * @param input\n * A value to create an observable from.\\\n * This observable is then going to be listened to in order to set the refs.\n *\n * @param defaultValues\n * A map of default values for each ref.\n */\nexport function refsFrom<R, E>(input: ObservableInput<R>, defaultValues: Subscribers<R, E>): Refs<R, E>;\n\nexport function refsFrom(input: ObservableInput<any>, defaultValues: Partial<Subscribers<any, any>> = {}) {\n  const next = ref(defaultValues.next);\n  const error = ref(defaultValues.error);\n  const value$ = untilUnmounted(from(input));\n\n  return {\n    next,\n    error,\n    value$,\n    subscription: value$.subscribe({\n      next: v => next.value = v,\n      error: v => error.value = v,\n    })\n  };\n}\n","import { Ref, UnwrapRef, ref, watch, WatchOptions, WatchStopHandle } from 'vue';\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto the first.\n */\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to }: { to: Mapper<R1, UnwrapRef<R2>> },\n): SyncedRef<R1, 'to', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { from }: { from: Mapper<UnwrapRef<R2>, R1> },\n  defaultValue?: R2,\n): SyncedRef<R1, 'from', UnwrapRef<R2>>;\n\nexport function syncRef<R1, R2>(\n  ref1: Ref<R1>,\n  { to, from }: { to: Mapper<R1, UnwrapRef<R2>>, from: Mapper<UnwrapRef<R2>, R1> },\n): SyncedRef<R1, 'to' | 'from', UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The resulting ref serves as an origin point for the binding,\\\n * values **from** the resulting ref and **to** the resulting ref are mapped onto the first.\n */\nexport function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  defaultValue?: R2,\n): SyncedRef<R1, keyof M, UnwrapRef<R2>>;\n\n/**\n * Creates a binding between two refs.\\\n * The binding can be:\n * - One-way if only the one mapper is defined.\n * - Two-way if both mappers (`to` and `from`) are defined.\n *\n * The second ref serves as an origin point for the binding,\\\n * values **from** the second ref and **to** the second ref are mapped onto the first.\n */\nexport function syncRef<R1, R2, M extends Readonly<Mappers<R1, R2>> = Mappers<R1, R2>>(\n  ref1: Ref<R1>,\n  { to, from }: M,\n  ref2: Ref<R2>,\n): SyncedRef<R1, keyof M, R2>;\n\nexport function syncRef<R1, R2>(\n  this: WatchOptions,\n  ref1: Ref<R1>,\n  maps: Mappers<R1, R2>,\n  _ref2?: Ref<R2> | R2,\n): _SyncedRef<R1, keyof Mappers<R1, R2>, R2> {\n  const ref2 = ref(\n    _ref2 == null\n      ? maps.to\n        ? maps.to(ref1.value)\n        : ref1.value\n      : _ref2\n  ) as _SyncedRef<R1, keyof Mappers<R1, R2>, R2>;\n\n  for (const key in maps) (\n    ref2[key as keyof typeof maps] = bind(ref1, ref2, maps, key as any, this)\n  ).bind();\n\n  return ref2;\n}\n\nsyncRef.with = <T extends Readonly<boolean> = false>(\n  ...options: WatchOptions<T>[]\n): typeof syncRef => {\n  const opts = Object.assign({}, ...options);\n  const f = syncRef.bind(opts);\n  f.with = syncRef.with.bind(opts);\n  return f;\n}\n\nconst bind = <R1, R2>(\n  refBase: Ref<R1>,\n  refDest: _SyncedRef<R1, keyof Mappers<R1, R2>, R2>,\n  maps: Mappers<R1, R2>,\n  dir: keyof Mappers<R1, R2>,\n  options: WatchOptions,\n) => ({\n  bind: (bindOptions?: Partial<BindingOptions<R1, R2, keyof Mappers<R1, R2>>>) => {\n    const {\n      ref, map, watch: opts\n    }: BindingOptions<any, R2, any> = {\n      ref: refBase,\n      map: maps[dir]!,\n      watch: options,\n      ...bindOptions,\n    };\n\n    refDest[dir]!.stop();\n\n    refDest[dir]!.stop = dir === 'to'\n      ? watch(ref, v => refDest.value = map(v), Object.assign({}, options, opts))\n      : watch(refDest, v => ref.value = map(v), Object.assign({}, options, opts));\n  },\n  stop: () => {}\n});\n\ntype Mapper<F, T> = (value: F) => T;\n\ntype Mappers<R1, R2> = {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from?: never,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to?: never,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n} | {\n  /**\n   * A map from the first ref to the second\n   */\n  to: Mapper<R1, R2>,\n\n  /**\n   * A map from the second ref to the first\n   */\n  from: Mapper<R2, R1>,\n};\n\ntype Binders<R1, R2, Keys extends PropertyKey> = {\n  [key in Keys]: {\n    /**\n     * Cut the binding in this direction\n     */\n    stop: WatchStopHandle;\n    bind: {\n      /**\n       * Reapply the binding in this direction\n       */\n      (): void;\n\n      /**\n       * Bind this direction to a new ref\n       */\n      (options?: BindingOptions<R1, R2, key>): void;\n\n      /**\n       * Bind this direction to a new ref with a new map\n       */\n      <T>(options: CustomBindingOptions<T, R2, key>): void;\n    };\n  };\n};\n\nexport type BindingOptions<R1, R2, Key extends PropertyKey> = {\n  ref?: Ref<R1>;\n  map?: Key extends 'to' ? Mapper<R1, R2> : Mapper<R2, R1>;\n  watch?: WatchOptions;\n}\n\nexport type CustomBindingOptions<T, R2, Key extends PropertyKey> = {\n  ref: Ref<T>;\n  map: Key extends 'to' ? Mapper<T, R2> : Mapper<R2, T>;\n  watch?: WatchOptions;\n}\n\nexport type SyncedRef<\n  R1,\n  Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Binders<R1, R2, Keys>;\n\ntype _SyncedRef<\n  R1,\n  _Keys extends PropertyKey,\n  R2,\n> = Ref<R2> & Partial<Binders<R1, R2, keyof Mappers<R1, R2>>>;\n","import { Unsubscribable } from 'rxjs';\nimport { onUnmounted } from 'vue';\n\n/**\n * Automatically unsubscribes from a subscription when onUnmounted hook executes\n * @param subscrition - what to unsubscribe from\n */\nexport const useSubscription = (subscrition: Unsubscribable) => onUnmounted(() => subscrition.unsubscribe());\n"],"names":["fromHook","hook","Observable","ctx","getCurrentInstance","pipeUntil","takeUntil","untilUnmounted","onUnmounted","canMergeDeep","state","mutation","key","deepReplaceArray","submutation","defaultOptions","useRxState","initialState","options","mergeKeys","reducers","map$","reactive","callMeMaybe","actions","actions$","actions$Arr","complete","error","context","e","mutations$","Subject","args","mergeScan","prev","curr","isObservable","of","map","tap","merged$","merge","createRxResult","readonly","scan","result","fn","deep","shallow","mapError","cb","catchError","$","setRef","ref","v","fromRef","watch","value","refFrom","arg","subArg","isProxy","ref$","from","toRef","refsFrom","input","defaultValues","next","value$","syncRef","ref1","maps","_ref2","ref2","bind","opts","f","refBase","refDest","dir","bindOptions","useSubscription","subscrition"],"mappings":";;;AAgBa,MAAAA,IAAW,CAACC,MAAkB,IAAIC;AAAA,EAC7C,CAAOC,MAAA;AAAE,IAAAC,EAAwB,KAAAH,EAAK,MAAME,EAAI,KAAM,CAAA;AAAA,EAAE;AAC1D,GCJaE,IAAY,CAAIJ,MAAkBK,EAAaN,EAASC,CAAI,CAAC,GAS7DM,IAAyDF,EAAUG,CAAW,GCU9EC,IAAe,CAC1BC,GACAC,GACAC,MAEAD,KAAY,QACT,OAAOA,EAASC,CAAG,KAAM,YACzB,OAAOF,EAAME,CAAG,KAAM,UCzBdC,IAAmB,CAC9BH,MACG,CACHC,MACG;AACH,aAAWC,KAAOD,GAAU;AACpB,UAAAG,IAAcH,EAASC,CAAG;AAEhC,IAAAF,EAAME,CAAc,IAAI,CAAC,MAAM,QAAQE,CAAW,KAAKL,EAAaC,GAAOC,GAAUC,CAAG,IACpFC,EAAiBH,EAAME,CAAG,CAAC,EAAEE,CAAW,IACxCA;AAAA,EACN;AAEO,SAAAJ;AACT,GCdaK,IAAiB;AAAA,EAC5B,kBAAkBF;AACpB;AAWgB,SAAAG,EACdC,GACAC,GAC8C;AACxC,QAAA,EAAE,kBAAkBC,MAAc;AAAA,IACtC,GAAGJ;AAAA,IACH,GAAGG;AAAA,EAAA;AAGE,SAAA,SAAUE,GAAUC,GAAO;AAKhC,UAAMX,IAAQY,EAASC,EAAYN,CAAY,CAAC,GAE1CO,IAAoB,CAAA,GACpBC,IAA4C,CAAA,GAC5CC,IAAgC,CAAA;AAEtC,QAAIC,IAAW,IACXC;AAEJ,UAAMC,IAA2B;AAAA,MAC/B,OAAO,CAAKC,MAAA;AAAU,QAAAF,IAAAE;AAAA,MAAG;AAAA,MACzB,UAAU,MAAM;AAAa,QAAAH,IAAA;AAAA,MAAM;AAAA,IAAA;AAGrC,eAAWf,KAAOQ,GAAU;AACpB,YAAAW,IAAa,IAAIC;AAEvB,MAAAR,EAAQZ,CAAG,IACT,IAAIqB,MAAgBF,EAAW;AAAA,QAC7BX,EAASR,CAAG,EAAE,MAAMQ,GAAUa,CAAI;AAAA,MAAA,GAI1BP,EAAA;AAAA,QACVD,EAAS,GAAGb,IAAe,IACzBsB,EAAU,CAACC,GAASC,OACXA,IAAAb,EAAYa,GAAMD,GAAMN,CAAO,IAGpCQ,EAAaD,CAAI,IACbA,IACAE,EAAGF,CAAI,GACX;AAAA,UACAG,EAAIpB,EAAUgB,GAAMhB,CAAS,CAAC;AAAA,UAC9BqB,EAAI;AAAA,YACF,MAAM,MAAMZ,IACRA,IAAQG,EAAW,MAAMH,CAAK,IAC9BD,KAAYI,EAAW,SAAS;AAAA,UAAA,CACrC;AAAA,QAAA,IAEFrB,CAAK,EAAEqB,CAAU;AAAA,MAAA;AAAA,IAG1B;AAEM,UAAAU,IAAUC,EAAM,GAAGhB,CAAW;AAEpC,WAAOiB,EAAe;AAAA,MACpB,SAAAnB;AAAA,MACA,OAAOoB,EAASlC,CAAU;AAAA,MAC1B,QAAQH;AAAA,QACNc,IAAOA;AAAA,UACLoB;AAAA,UACArB;AAAA,UACAV;AAAA,UACAe;AAAA,UACAI;AAAA,QAAA,EACA;AAAA,UACAgB,EAAK,CAACV,GAAMC,MAASjB,EAAUgB,GAAMhB,CAAS,EAAEiB,CAAI,GAAG1B,CAAK;AAAA,QAAA,IAC1D+B;AAAA,MACN;AAAA,MACA,UAAAhB;AAAA,IAAA,CACD;AAAA,EAAA;AAEL;AAmDA,MAAMkB,IAAiB,CAAaG,OAKK;AAAA,EACvC,GAAGA;AAAA,EACH,WAAW,IAAIb,OAAiB;AAAA,IAC9B,GAAGa;AAAA,IACH,cAAcA,EAAO,OAAO,UAAU,GAAGb,CAAI;AAAA,EAAA;AAEjD,IAEMV,IAAc,CAClBwB,MACGd,MAEH,OAAOc,KAAO,aACTA,EAAyB,GAAGd,CAAI,IACjCc,GC/IOC,IAAO,CAClBtC,MACG,CACHC,MACG;AACH,aAAWC,KAAOD;AAChB,IAAAD,EAAME,CAAc,IAAIH,EAAaC,GAAOC,GAAUC,CAAG,IACrDoC,EAAKtC,EAAME,CAAG,CAAC,EAAED,EAASC,CAAG,CAAC,IAC9BD,EAASC,CAAG;AAGX,SAAAF;AACT,GClCauC,IAAU,CACrBvC,MACG,CACHC,MACG;AACH,aAAWC,KAAOD;AACV,IAAAD,EAAAE,CAAG,IAAID,EAASC,CAAG;AAGpB,SAAAF;AACT,GClBawC,IAAW,CAAUC,MAChCC,EAA6B,CAAC,GAAGC,MAAM;AAAQ,QAAAF,EAAG,GAAGE,CAAC;AAAG,CAAC,GCD/CC,KAAS,CAAIC,MAAgBf,EAAO,EAAE,MAAM,CAAKgB,MAAAD,EAAI,QAAQC,EAAG,CAAA;ACsB7D,SAAAC,GAAQF,GAAqDrC,GAA6C;AACjH,SAAAX;AAAA,IACL,IAAIL,EAAW,CAAAC,MAAOuD,EAAMH,GAAK,CAASI,MAAAxD,EAAI,KAAKwD,CAAK,GAAGzC,CAAO,CAAC;AAAA,EAAA;AAEvE;AC4DgB,SAAA0C,GAAQC,GAAcC,GAAkB;AACtD,MAAI,OAAOD,KAAQ,YAAY,CAACE,EAAQF,CAAG;AAAO,QAAA;AAC1C,YAAAG,IAAOT,EAAIO,CAAM;AAEvB,aAAAvD,EAAe0D,EAAKJ,CAAU,CAAC,EAAE,UAAU;AAAA,QACzC,MAAM,CAASF,MAAAK,EAAK,QAAQL;AAAA,MAAA,CAC7B,GAEMK;AAAA;IAC+C;AAEjD,SAAAD,EAAQF,CAAG,IACdK,EAAML,GAAyBC,CAAM,IACrCP,EAAIM,CAAG;AACb;ACjDO,SAASM,GAASC,GAA6BC,IAAgD,IAAI;AAClG,QAAAC,IAAOf,EAAIc,EAAc,IAAI,GAC7BzC,IAAQ2B,EAAIc,EAAc,KAAK,GAC/BE,IAAShE,EAAe0D,EAAKG,CAAK,CAAC;AAElC,SAAA;AAAA,IACL,MAAAE;AAAA,IACA,OAAA1C;AAAA,IACA,QAAA2C;AAAA,IACA,cAAcA,EAAO,UAAU;AAAA,MAC7B,MAAM,CAAKf,MAAAc,EAAK,QAAQd;AAAA,MACxB,OAAO,CAAKA,MAAA5B,EAAM,QAAQ4B;AAAA,IAAA,CAC3B;AAAA,EAAA;AAEL;ACXgB,SAAAgB,EAEdC,GACAC,GACAC,GAC2C;AAC3C,QAAMC,IAAOrB;AAAA,IACXoB,MACID,EAAK,KACHA,EAAK,GAAGD,EAAK,KAAK,IAClBA,EAAK;AAAA,EACP;AAGN,aAAW7D,KAAO8D;AAChB,KAAAE,EAAKhE,CAAwB,IAAIiE,EAAKJ,GAAMG,GAAMF,GAAM9D,GAAY,IAAI,GACxE,KAAK;AAEA,SAAAgE;AACT;AAEAJ,EAAQ,OAAO,IACVtD,MACgB;AACnB,QAAM4D,IAAO,OAAO,OAAO,CAAA,GAAI,GAAG5D,CAAO,GACnC6D,IAAIP,EAAQ,KAAKM,CAAI;AAC3B,SAAAC,EAAE,OAAOP,EAAQ,KAAK,KAAKM,CAAI,GACxBC;AACT;AAEA,MAAMF,IAAO,CACXG,GACAC,GACAP,GACAQ,GACAhE,OACI;AAAA,EACJ,MAAM,CAACiE,MAAyE;AACxE,UAAA;AAAA,MACJ,KAAA5B;AAAAA,MAAK,KAAAhB;AAAA,MAAK,OAAOuC;AAAA,IAAA,IACe;AAAA,MAChC,KAAKE;AAAA,MACL,KAAKN,EAAKQ,CAAG;AAAA,MACb,OAAOhE;AAAA,MACP,GAAGiE;AAAA,IAAA;AAGG,IAAAF,EAAAC,CAAG,EAAG,QAEdD,EAAQC,CAAG,EAAG,OAAOA,MAAQ,OACzBxB,EAAMH,GAAK,CAAKC,MAAAyB,EAAQ,QAAQ1C,EAAIiB,CAAC,GAAG,OAAO,OAAO,CAAC,GAAGtC,GAAS4D,CAAI,CAAC,IACxEpB,EAAMuB,GAAS,CAAAzB,MAAKD,EAAI,QAAQhB,EAAIiB,CAAC,GAAG,OAAO,OAAO,CAAI,GAAAtC,GAAS4D,CAAI,CAAC;AAAA,EAC9E;AAAA,EACA,MAAM,MAAM;AAAA,EAAC;AACf,ICxGaM,KAAkB,CAACC,MAAgC7E,EAAY,MAAM6E,EAAY,YAAa,CAAA;"}